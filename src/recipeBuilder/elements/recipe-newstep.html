<link rel="import" href="polymer-require.html">

<polymer-element name="recipe-newstep" attributes="builder" hidden>
  <script>
  var
    Menu,
    Step = function(name) {
      this.name = name;
      this.toString = function() { return this.name; };
    },
    Steps = [
      new Step('Add Ingredient'),
      new Step('Heating'),
      new Step('Splitting'),
      new Step('Merging'),
      new Step('Create Ingredient'),
      new Step('Ferment')
    ];

  function StepState() {
    this.name = null;
    this.ingredient = null;
    this.type = null;
  };

  function StepBuilder(step) {
    this.step = step;
    this.ingredient;
    this.timing;
    this.qty;
  }

  function registerType(state, data) {
    if (data === null) return Promise.reject();
    state.type = data.name;
    return state;
  }
  function registerName(state, data) {
    if (data === null) return Promise.reject();
    state.name = data.value;
    return state;
  }
  function registerIngredient(state, data) {
    if (data === null) return Promise.reject();
    state.ingredient = data.ingredient;
    state.qty = {value: data.value, unit: data.unit};
    return state;
  }

  Polymer('recipe-newstep', {
    busEvt: 'CreateStep',
    evtSend: 'NewStepCreated',
    isChoosing: false,

    ready: function() { require(['base/bus'], this.onReady.bind(this)); },
    onReady: function(bus) { window.bus.register(this, this.busEvt); },

    // Begin step
    onCreateStep: function(data) {
      if (this.isChoosing) return;
      this.beginBuilder()
        .then(this.onStateMachine.bind(this))
        .then(this.endBuilder.bind(this))
        .then(this.sendResult.bind(this))
        .catch(function() {
          // If there was an error, just catch so nothing crashes.
        });
    },

    // State Machine
    onStateMachine: function(state) {
      if (state.type === null) return this.askType(state);
      if (state.name === null) return this.askName(state);
      if (state.ingredient === null) return this.askIngredient(state);
      return state;
    },

    beginBuilder: function() {
      this.isChoosing = true;
      return Promise.resolve(new StepState());
    },
    endBuilder: function(state) {
      this.isChoosing = false;
      return state;
    },
    sendResult: function(state) {
      window.bus.broadcast(this.evtSend, state);
      return state;
    },

    onBegin: function() {
      this.isChoosing = true;
    },

    // Dialogs
    askType: function(state) {
      return bus.evt2promise('AskMenu', Steps, 'AnswerMenu')
        .then(registerType.bind(this, state))
        .then(this.onStateMachine.bind(this))
        .catch(function() {
          // If there was an error, just catch so nothing crashes.
        });
    },
    askName: function(state) {
      return bus.evt2promise('AskText', 'Task Name', 'AnswerText')
        .then(registerName.bind(this, state))
        .then(this.onStateMachine.bind(this));
    },
    askIngredient: function(state) {
      return bus.evt2promise('AskIngredient', this.builder.inventory.stocks, 'AnswerIngredient')
        .then(registerIngredient.bind(this, state))
        .then(this.onStateMachine.bind(this));
    },

    onAnswerMenu: function(data) {
      switch (data.selected.name) {
        case 'Add Ingredient':
          this.onAddingIngredient();
          break;
      }
      this.isChoosing = false;
    },
    onAddingIngredient: function() {
      Menu.ask(this.builder.ingredients.listAllIngredients())
        .then(this.onChosenIngredient.bind(this, new StepBuilder('Add Ingredient')));
    },
    onChosenIngredient: function(stepBld, ingredient) {
      stepBld.ingredient = ingredient.selected;
      Menu.ask(['After', 'OnTrigger']).then(this.onChooseStep.bind(this, stepBld));
    },
    onChooseStep: function(stepBld, timing) {
      stepBld.timing = timing.selected;
      var steps = [];
      this.builder.recipe.reactors.forEach(function(reactor) {
        reactor.steps.forEach(function(step) {
          steps.push({
            reactor: reactor,
            step: step,
            toString: function() {
              return this.reactor.name + ' - ' + this.step.name;
            }
          });
        });
      });

      Menu.ask(steps).then(this.onStepChosen.bind(this, stepBld));
    },
    onStepChosen: function(stepBld, step) {
      stepBld.qty = prompt("Enter quantity");
      step.selected.reactor.addAfter(
        step.selected.step, stepBld
      );
    }
  });
  </script>
</polymer-element>